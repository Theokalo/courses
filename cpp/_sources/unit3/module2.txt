Ενότητα 3-2
=============

Πώς και τι περνά ως όρισμα σε μια συνάρτηση
--------------------------------------------

Στην εξ'ορισμού λειτουργία η C++ περνά τις παραμέτρους στις συναρτήσεις *by value*: τα δεδομένα εισόδου κατά την κλήση της συνάρτησης **αντιγράφονται** στις παραμέτρους εισόδου. Τα αντίγραφα αυτά είναι τελείως ξεχωριστά, έτσι ο κώδικας της συνάρτησης **δεν μπορεί να αλλάξει τιμή στα πρωτότυπα αντικείμενα**: 

.. literalinclude:: testparam1.cpp
   :language: c++

* Με το πέρασμα παραμέτρων *by value* κάθε συνάρτηση έχει τις τοπικές (local) μεταβλητές της και τις παραμέτρους εισόδου (formal parameters) αποκλειστικά ιδιωτικές.
* Οι μεταβλητές αυτές έχουν διάρκεια ζωής όση η συνάρτηση που τις περιέχει.
* Καμία άλλη συνάρτηση δεν μπορεί να μεταβάλει τις τιμές των μεταβλητών αυτών.

Πώς θα μπορέσει μία συνάρτηση να αλλάξει τιμή σε εξωτερικές μεταβλητές;

Πέρασμα παραμέτρων by reference
-----------------------------------
Με τη μέθοδο περάσματος των παραμέτρων σε μια συνάρτηση *by reference*, τα ορίσματα εισόδου **δεν αντιγράφονται**. Αντιθέτως, αυτό που περνά στη συνάρτηση είναι μια "αναφορά" στην πρωτότυπη μεταβλητή. Μέσω της αναφοράς αυτής η συνάρτηση μπορεί να θέσει νέες τιμές στο πρωτότυπο (εξωτερικό) αντικείμενο.

Η C++ διαθέτει έναν πολύ εύκολο μηχανισμό (**references**) για τον σκοπό αυτόν!

.. literalinclude:: testparam2.cpp
   :language: c++
   
* Η δήλωση του reference χρησιμοποιεί το &:

  .. code-block:: c++
  
     int &i
     
     //Μπορείτε να γράψετε επίσης:
    
     int& i	// Ισοδύναμο με προηγούμενο. Είνα θέμα στυλ ποιο θα διαλέξετε.
     		// Και τα δύο είναι σωστά για τον μεταγλωττιστή!
  
  Αυτό σημαίνει ότι το i είναι reference σε μεταβλητή τύπου int.
   
* Δεν μπορούμε να αλλάξουμε την τιμή του reference. Γράφοντας π.χ. ++i επενεργούμε στη μεταβλητή που "δείχνει" το i κι όχι στο i καθεαυτό.

* Ένα reference μπορεί να δημιουργηθεί και με άλλον τρόπο εκτός από το πέρασμα σε συνάρτηση, δεν θα το καλύψουμε όμως εδώ.

By value ή by reference;
-------------------------
Πρακτικοί κανόνες, αν δεν συντρέχει ειδικός λόγος πρέπει να ακολουθούνται:

* **Τα ορίσματα είναι απλού τύπου (bool, char, int, double)**

  * Μπορείτε να περάσετε τις παραμέτρους by value.
  * Αν θέλετε να αλλάξετε την τιμή της εξωτερικής μεταβλητής (πάντα απλού τύπου), μπορείτε να επιστρέφετε τη νέα τιμή όταν τελειώνει η συνάρτηση.
  
* **Τα ορίσματα είναι σύνθετου τύπου (αντικείμενα κλάσεων ορισμένων από τη C++ ή δικών σας κλάσεων)**

  * Πρέπει να περάσετε τις παραμέτρους **οπωσδήποτε** by reference
  
    * *Αν περάσετε τις παραμέτρους by value, θα συμβούν δαπανηρές αντιγραφές ή, ακόμα χειρότερα, σφάλματα εκτέλεσης (περισσότερα για αυτό σε επόμενα).* 

  * Το πέρασμα by reference επιτρέπει τη μεταβολή των πρωτότυπων αντικειμένων.
  
Const references
------------------
Σημειώνοντας μια αναφορά ως **const** δηλώνουμε ότι η πρωτότυπη μεταβλητή είναι read-only για τον κώδικα της συνάρτησης. Εάν προσπαθήσουμε μέσα στη συνάρτηση να τροποποιήσουμε τη μεταβλητή στην οποία "δείχνει" η αναφορά, Θα προκληθεί σφάλμα μεταγλώττισης! 

.. literalinclude:: testparam3.cpp
   :language: c++

**Προσοχή!! Μερικές φορές είναι απαραίτητο να δηλώσουμε ένα όρισμα συνάρτησης ως const reference!!**
Παρατηρήστε τι συμβαίνει στον επόμενο κώδικα:

.. literalinclude:: testconstref.cpp
   :language: c++
   :linenos:

Το πρόβλημα εμφανίζεται στην κλήση της συνάρτησης testfunc2() στη γραμμή 21:

* Στη συνάρτηση περνά μια σταθερή συμβολοσειρά "hello world v2!".
* Για να δημιουργήσει ο μεταγλωττιστής το reference που απαιτείται ως όρισμα εισόδου, θα κατασκευαστεί ένα **προσωρινό αντικείμενο** με τιμή "hello world v2!".
* Το αντικείμενο αυτό δεν μπορεί να το χειριστεί ο προγραμματιστής ("δεν έχει όνομα"), συνεπώς θα είναι δηλωμένο αυτόματα ως **const** (read-only).
* H C++  όμως **επιμένει** να δημιουργεί const references από const αντικείμενα.
* Συνεπώς η αναφορά που θα δείχνει στο προσωρινό "hello world v2!" θα είναι const και δεν θα ταιριάζει με το όρισμα που δέχεται η testfunc2() (reference αλλά όχι const).

Εμβέλεια (Scope)
-----------------
* Οι τοπικές μεταβλητές και οι παράμετροι της συνάρτησης ζούν όσο η συνάρτηση που τις περικλείει.
* Μέσα σε μια συνάρτηση μπορούμε να ανοίξουμε μπλοκ με {} και να δηλώσουμε νέες τοπικές μεταβλητές.
  
  * Αυτές έχουν εμβέλεια μόνο μέσα στο μπλοκ που τις περιέχει.
  * Όταν η εκτέλεση βγει από το μπλοκ, οι μεταβλητές αυτές θα καταστραφούν.
  * Αν σε οποιοδήποτε σημείο του κώδικα υπάρχει ίδιο όνομα μεταβλητής στο εσωτερικό μπλοκ και σε άλλα που το περιβάλλουν, υπερισχύει η μεταβλητή στο πιο εσωτερικό μπλοκ.
  
Παραδείγματα:

.. literalinclude:: scope.cpp
   :language: c++
  
.. note::
   Οι καθολικές (global) μεταβλητές -κληρονομιά της C- έχουν εμβέλεια παντού στο αρχείο, αρκεί να μην επικαλύπτονται από τοπικές μεταβλητές με το ίδιο όνομα. Η χρήση τους παραβιάζει τις αρχές του αντικειμενοστρεφούς προγραμματισμού, γι'αυτό καλό είναι να μην χρησιμοποιούνται!
   
Τι επιστρέφει μια συνάρτηση
-----------------------------
* Μεταβλητές τύπου native.
* Αντικείμενα κλάσεων, με αντιγραφή σε προσωρινό αντικείμενο.
* Αναφορές (references) αλλά προσοχή: πρέπει το αντικείμενο που αυτές "δείχνουν" να ζεί και μετά το τέλος της συνάρτησης!
   
