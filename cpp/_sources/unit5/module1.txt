Ενότητα 5-1
===============

Αρχείο επικεφαλίδων (header file)
-----------------------------------
Για να χρησιμοποιήσουμε την κλάση ``Employee`` της προηγούμενης ενότητας αρκεί να ξέρουμε:

* Τη δήλωση της κλάσης.
* Τον κώδικα των συναρτήσεων inline (αν υπάρχουν).

**Δεν απαιτείται η γνώση των λεπτομερειών υλοποίησης (ορισμός) των κανονικών συναρτήσεων της κλάσης.**

Η πληροφορία αυτή μπαίνει σε ξεχωριστό αρχείο επικεφαλίδων (έστω ότι το ονομάζουμε ``employee.h``):

.. literalinclude:: employee0/employee.h
   :language: c++

**Παρατηρήσεις**

* Το αρχείο αυτό θα ενσωματωθεί όπου χρειάζεται μέσω της οδηγίας ``#include``:

  .. code-block:: c++

     #include "employee.h"

  Ο μεταγλωττιστής θα αντικαταστήσει την παραπάνω γραμμή με το κείμενο από το ``employee.h``.

* Τα παρακάτω χρησιμοποιούνται για την αποφυγή περιπτώσεων πολλαπλών include του ίδιου αρχείου (include guards):

  .. code-block:: c++
  
     #ifndef EMPLOYEE_H__
     #define EMPLOYEE_H__
     
     // ...περιεχόμενο...
     
     #endif
     
   
* Δεν είναι σωστό να περιλάβουμε μέσα στο αρχείο επικεφαλίδων το ``using namespace std;`` εφόσον θα ισχύει και **μετά** το τέλος του αρχείου (δηλαδή **και** στο αρχείο που ενσωματώνει το ``employee.h``, μετά το ``#include "employee.h"``). Συνεπώς είμαστε υποχρεωμένοι να προσθέσουμε ρητά το ``std::`` όπου χρειάζεται.

Αρχείο που περιέχει τη main()
--------------------------------
Το αρχείο της main() (``employeemain.cpp``) τώρα γίνεται:

.. literalinclude:: employee0/employeemain.cpp
   :language: c++

Αυτό το αρχείο μπορεί να μεταγλωττιστεί, **όχι όμως και να παραχθεί εκτελέσιμος κώδικας** (δεν υπάρχει ο ορισμός του constructor ούτε το πώς υλοποιείται το << για την κλάση Employee!): ::

   g++ -Wall -c employeemain.cpp
   
Αυτό που θα παραχθεί είναι ο κώδικας-αντικείμενο (object code) από τον πηγαίο κώδικα του ``employeemain.cpp``. Το αρχείο object-code, εφόσον δεν ορίζεται αλλιώς, θα λέγεται ``employeemain.o``.

Αρχείο υλοποίησης (implementation file)
------------------------------------------
Περιέχει τον κώδικα υλοποίησης των συναρτήσεων της κλάσης Employee (``employee.cpp``).

.. literalinclude:: employee0/employee.cpp
   :language: c++

**Παρατηρήσεις**

* Και το αρχείο υλοποίησης ενσωματώνει το ``employee.h``.
* Αν υπήρχαν static μεταβλητές-μέλη της κλάσης, θα έπρεπε να οριστούν εδώ.
* Το αρχείο υλοποίησης μπορεί να μεταγλωττιστεί επίσης ξεχωριστά (το αρχείο object-code θα λέγεται ``employee.o``): ::
  
     g++ -Wall -c employee.cpp
     
Παραγωγή εκτελέσιμου κώδικα
-------------------------------
Από τα ``employee.o`` και ``employeemain.o``, το τελικό εκτελέσιμο αρχείο θα ονομάζεται ``employee``: ::

   g++ employee.o employeemain.o -o employee
   
Η διαδικασία της επι μέρους μεταγλώττισης και παρακολούθησης των αρχείων που αλλάζουν είναι επίπονη. Τα ολοκληρωμένα περιβάλλοντα ανάπτυξης (IDEs) το κάνουν αυτόματα ενώ εδώ μπορούμε να χρησιμοποιήσουμε το πρόγραμμα **make**. Αυτό παίρνει ως είσοδο ένα αρχείο με οδηγίες (ποιος είναι ο στόχος και ποιες οι αλληλοεξαρτήσεις μεταξύ αρχείων), όπως το επόμενο (έστω ``employee.make``):

.. literalinclude:: employee0/employee.make
   :language: make

Συνοπτικά, το αρχείο αυτό λέει ότι:

* Ο κύριος στόχος ``employee`` εξαρτάται απο δύο υπο-στόχους (``employee.o`` και ``employeemain.o``), ενώ η εντολή που πρέπει να εκτελεστεί για τη δημιουργία του στόχου είναι η ``g++ employee.o employeemain.o -o employee``.

* Αντίστοιχα ορίζεται για κάθε έναν από τους υπο-στόχους οι εξαρτήσεις τους και ο τρόπος δημιουργίας τους.

* Με την πληροφορία αυτή, το make, ανάλογα με τα αρχεία κώδικα που έχουν αλλάξει, ξέρει ποιους στόχους πρέπει να επικαιροποιήσει.

* Αυτό γίνεται ως εξής: ::
     
     make -f employee.make
     
  και το αποτέλεσμα θα είναι ένα πάντοτε ενημερωμένο εκτελέσιμο ``employee``.
  
.. note::
   **Προσοχή!** η γραμμή της εντολής πρέπει να αρχίζει με ένα (και μόνο) χαρακτήρα TAB, χωρίς άλλα κενά!
   

  
