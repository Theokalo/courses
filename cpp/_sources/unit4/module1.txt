Ενότητα 4-1
==============

Εισαγωγή στις κλάσεις
---------------------------
Οι κλάσεις ορίζουν σύνθετους τύπους αντικειμένων (σε αντίθεση με τους native τύπους) και αποτελούν το κύριο εργαλείο αντικειμενοστρεφούς προγραμματισμού. Μια κλάση δηλώνεται με τη λέξη κλειδί **class**:

.. code-block:: c++
  
   class Test {
   public:
     int i;
     Test(int a,int b,int c);
   protected:
     int j;
   private:
     //int err = 3;	NOTE! Cannot init a non-static variable! Compilation error.
     int k;  
   };
     
Η δήλωση αυτή είναι το "αρχιτεκτονικό σχέδιο" της κλάσης: δεν δεσμεύει χώρο μνήμης η ίδια, αλλά θα χρησιμοποιηθεί για τη δημιουργία στιγμιοτύπων της κλάσης (objects στην ορολογία της C++).

Όπως φαίνεται στο προηγούμενο παράδειγμα, η κλάση μπορεί να περικλείει μεταβλητές (member variables) και συναρτήσεις (member functions).

.. note::
   Οι μεταβλητές **δεν μπορούν να αρχικοποιούνται** μέσα στη δήλωση της κλάσης!
   
Οι λέξεις κλειδιά **public**, **protected** και **private** προσδιορίζουν τον τρόπο προσπέλασης των μελών μιας κλάσης (access specifiers):

* **public:** πρόσβαση στα μέλη αυτά έχει ο κώδικας απ'οποιοδήποτε σημείο του προγράμματος.
* **private:** τα μέλη αυτά μπορεί να προσπελάσει μόνο κώδικας από συναρτήσεις της ίδιας της κλάσης.  
* **protected:** μέχρι να μιλήσουμε για κληρονομικότητα, ισοδυναμεί με private.

Αν δεν υπάρχει access specifier, τα μέλη που ακολουθούν είναι private (η C++ μας δείχνει τον "σωστό τρόπο" χρήσης). Δεν είναι υποχρεωτικό να εμφανίζονται τα public, protected και private μόνο μια φορά.

Ο κώδικας των συναρτήσεων της κλάσης πρέπει να οριστεί στη συνέχεια. Η δήλωση:

.. code-block:: c++
  
     Test(int a,int b,int c);

προσδιορίζει μια ειδικού τύπου συνάρτηση με όνομα ίδιο με της κλάσης, για την οποία θα μιλήσουμε σε λίγο.

Εφόσον έχει προηγηθεί η δήλωση της κλάσης Test, μια μεταβλητή αντικειμένου της κλάσης Test μπορεί να οριστεί όπως ακριβώς κάθε native μεταβλητή:

.. code-block:: c++

   int main() {
     Test tob(1,2,3);

     return 0;
   }
    
Η δήλωση-αρχικοποίηση της μεταβλητής tob ως αντικείμενο της κλάσης Test

.. code-block:: c++

     Test tob(1,2,3);

έχει ως σκοπό να αρχικοποιήσει τα i, j και k του αντικειμένου tob στις τιμές 1, 2 και 3 αντίστοιχα. Κατά τη δημιουργία του αντικειμένου η C++ καλεί μια ειδική συνάρτηση-κατασκευαστή (constructor) της κλάσης, με τις παραμέτρους της δήλωσης (εδώ τα 1, 2, 3). Ο constructor δηλώνεται ως **public** συνάρτηση μέλος της κλάσης, με το όνομα της συνάρτησης **ίδιο** με εκείνο της κλάσης και **χωρίς τύπο επιστροφής** (δεν επιστρέφει ποτέ κάτι).

.. code-block:: c++
  
   public:
     Test(int a,int b,int c);

.. note::
   Αν και σπάνιο, μπορούμε να αρχικοποιήσουμε αντικείμενα χωρίς constructor. Η C++ καλεί έναν εξ'ορισμού constructor στην περίπτωση αυτή. Επίσης μπορούμε να δηλώσουμε πολλούς διαφορετικούς constructors για μια κλάση, αρκεί κάθε ένας να έχει διαφορετικό αριθμό ή/και τύπο παραμέτρων εισόδου (οπότε, ανάλογα με το πώς αρχικοποιούμε το αντικείμενο καθορίζεται και ποιος constructor θα κληθεί). Προσοχή: από τη στιγμή που θα ορίσουμε έστω και έναν constructor, δεν μπορούμε πλέον να χρησιμοποιήσουμε τον εξ'ορισμού constructor.
   
Ανάθεση αρχικών τιμών στα μέλη της κλάσης
--------------------------------------------
Η συνάρτηση constructor μπορεί να εκτελεί διάφορες λειτουργίες αρχικοποίησης, μία βασική όμως είναι η ανάθεση των αρχικών τιμών στις μεταβλητές μέλη της κλάσης με τον εξής τρόπο:

.. code-block:: c++

  Test::Test(int a,int b,int c): i(a),j(b),k(c) {

  }

Εδώ η μεταβλητή-μέλος i του αντικειμένου της κλάσης Test θα αρχικοποιηθεί με την τιμή της πρώτης παραμέτρου a, η j με τη δεύτερη παράμετρο b και η k με την c. Παρατηρήστε ότι ο constructor δεν εκτελεί άλλη λειτουργία εδώ, οπότε το σώμα της συνάρτησης είναι κενό (υπάρχουν μόνο τα { }).

.. note::
   Γιατί να μην γράψουμε το εξής;
   
   .. code-block:: c++

      Test::Test(int a,int b,int c): {
        i = a;
        j = b;
        k = c;
      }

   Αν και συντακτικά αυτό είναι σωστό, οι "έμπειροι" προγραμματιστές προτιμούν την πρώτη μορφή. Αν τα i, j και k δεν είναι μεταβλητές native τύπου, τότε η δεύτερη μορφή δεν είναι το ίδιο αποδοτική με την πρώτη.  

Προσπέλαση μελών ενός αντικειμένου
------------------------------------
Μέσα στον κώδικα των συναρτήσεων της κλάσης μπορούμε να αναφερθούμε στις μεταβλητές με το όνομά τους:

.. code-block:: c++

  i = j+k+99;

ενώ έξω από αυτές (π.χ. στο main()) χρησιμοποιούμε το .

.. code-block:: c++

   int main() {
     Test tob(1,2,3);
     cout << tob.i << endl;
     //cout << tob.j << endl;	ERROR! protected member
     //cout << tob.k << endl;	ERROR! private member
     return 0;
   }

Παρατηρήστε ότι ο κώδικας που δεν ανήκει σε συναρτήσεις της κλάσης δεν μπορεί να προσπελάσει τα private και protected μέλη!

Η "καλή πρακτική" στον αντικειμενοστρεφή προγραμματισμό θέλει να δηλώνονται οι μεταβλητές μιας κλάσης ως private και να παρέχονται συναρτήσεις public της κλάσης για την προσπέλασή τους ("getters" για την επιστροφή των τιμών των private μεταβλητών και "setters" για την ανάθεση τιμών σε αυτές). Έτσι απομονώνουμε από τον έξω κόσμο τις εσωτερικές λεπτομέρειες υλοποίησης μιας κλάσης και επιτρέπουμε μόνο ελεγχόμενη πρόσβαση στις μεταβλητές της.

.. code-block:: c++

   #include <iostream>

   using namespace std;

   class Test {
   private:
     int i;
   public:
     Test(int);
     int get_i();
   };

   Test::Test(int a): i(a) {
   
   }

   int Test::get_i() {	// getter
     return i;
   }


   int main() {
     Test tobj(3);

     cout << tobj.get_i() << endl;

     return 0;
   }

.. note::
   Σε περιπτώσεις **πολύ απλών** συναρτήσεων όπως η get_i(), μπορούμε να ορίσουμε τον κώδικα της συνάρτησης **μέσα στη δήλωση της κλάσης** ως εξής:
   
   .. code-block:: c++

      class Test {
      private:
        int i;
      public:
        Test(int);
        int get_i() { return i; }
      };

   Στην περίπτωση αυτή πρόκειται για συνάρτηση **inline**: ζητάμε από τον μεταγλωττιστή να μην δημιουργήσει κώδικα για τη συνάρτηση get_i() αλλά σε κάθε σημείο που καλείται η get_i() να τοποθετεί κατευθείαν τον κώδικα της (**χωρίς πραγματική κλήση της συνάρτησης!**). Γενικότερα, οι συναρτήσεις inline είναι διφορούμενης χρησιμότητας: μπορούν να βελτιώσουν την απόδοση ή να την μειώσουν. Απαιτείται πείρα για να αναγνωριστεί πότε πρέπει να χρησιμοποιηθούν, συνεπώς **αποφύγετε τη χρήση τους σε κάθε περίπτωση εκτός από το απλό { return something; }** του παραδείγματος!
   
