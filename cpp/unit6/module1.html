<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Ενότητα 6-1 &mdash; C++ Lectures v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="C++ Lectures v1.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">C++ Lectures v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>Ενότητα 6-1<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="stl">
<h2>Εισαγωγή στη βιβλιοθήκη STL<a class="headerlink" href="#stl" title="Permalink to this headline">¶</a></h2>
<p>Ένα πολύ σημαντικό τμήμα των standard βιβλιοθηκών της C++ είναι η βιβλιοθήκη STL (Standard Template Library). Αυτή βασίζεται στα templates: τον τρόπο της C++ να περιγράφει γενικό (generic) κώδικα που ενεργεί πάνω σε κάθε τύπο δεδομένων, αντί μόνο σε έναν (αντί π.χ. μόνο πάνω σε int).</p>
<p>Η συγγραφή κώδικα με templates είναι πολύπλοκη, το ίδιο και η μεταγλώττισή του. Ευτυχώς, <strong>η χρήση</strong> βιβλιοθηκών με templates είναι πολύ εύκολη, όπως θα φανεί στη συνέχεια!</p>
<p>Τα βασικά μέρη της βιβλιοθήκης STL είναι:</p>
<ul class="simple">
<li><strong>STL Containers:</strong> δομές δεδομένων για την αποθήκευση και διαχείριση δεδομένων του χρήστη. Τα δεδομένα μπορούν να είναι οποιουδήποτε τύπου, native ή user-defined.</li>
<li><strong>STL Iterators:</strong> &quot;δείχνουν&quot; σε κάποιο στοιχείο αποθηκευμένο σε container και επιτρέπουν τον χειρισμό του.</li>
<li><strong>STL Algorithms:</strong> κοινές λειτουργίες όπως αναζήτηση, ταξινόμηση κ.ά. σε containers. Οι λειτουργίες αυτές είναι ανεξάρτητες από το είδος του container, γιατί χρησιμοποιούν iterators.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Λεπτομέρειες θα δούμε στη συνέχεια, προς το παρόν σημειώνεται ότι: η βιβλιοθήκη STL έχει σχεδιαστεί και υλοποιηθεί από ειδικούς, έτσι ώστε να επιτυγχάνει τη βέλτιστη απόδοση. Πάντοτε πρέπει να τη χρησιμοποιούμε αντί να γράφουμε εκ νέου τον δικό μας κώδικα για λειτουργίες που παρέχει ήδη η STL.</p>
</div>
</div>
<div class="section" id="stl-vectors">
<h2>STL Vectors: Οδηγίες Χρήσης<a class="headerlink" href="#stl-vectors" title="Permalink to this headline">¶</a></h2>
<p>δύο είναι οι βασικές κατηγορίες STL containers:</p>
<ul class="simple">
<li><strong>Ακολουθιακά containers</strong>, μια αλληλουχία αντικειμένων (όπως ένας πίνακας, μια λίστα, μια ουρά..).</li>
<li><strong>Προσεταιριστικά containers</strong>, μια διατεταγμένη αντιστοιχία ζευγαριών &lt;Κλειδί-Τιμή&gt; (όπως ένα λεξικό).</li>
</ul>
<p>Τα vectors είναι τα πιο απλά και περισσότερο χρησιμοποιούμενα ακολουθιακά containers: Μονοδιάστατοι πίνακες για την αποθήκευση αντικειμένων σε σειρά με δυναμικό μέγεθος, διαχειριζόμενο από τη βιβλιοθήκη STL. Ο χρήστης δεν ασχολείται με το μέγεθος ένος vector, αυτό προσαρμόζετια αυτόματα για να χωρά τα αντικείμενα που εισάγει ο χρήστης.</p>
<p>Για να χρησιμοποιήσουμε τα vectors πρέπει να προσθέσουμε στα includes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;vector&gt;</span>
</pre></div>
</div>
<p>Στη συνέχεια μπορούμε να ορίσουμε μια μεταβλητή vector όπως συνήθως (προσέξτε τον τρόπο που δηλώνουμε ότι θέλουμε ένα vector που να περιέχει int):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>      <span class="c1">// an empty vector</span>
<span class="k">if</span> <span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;vector is empty&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;size=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; and capacity=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">vi</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Παρατηρήσεις:</p>
<ul class="simple">
<li>Όλες οι μεταβλητές τύπου STL container αρχικοποιούνται από τον constructor τους. Στο προηγούμενο παράδειγμα, το vi είναι empty αλλά αρχικοποιημένο.</li>
<li>Η συνάρτηση-μέλος empty() επιστρέφει true αν το vector είναι άδειο.</li>
<li>Η συνάρτηση-μέλος size() επιστρέφει το πλήθος των στοιχείων στο vector τη στιγμή αυτή.</li>
<li>Η συνάρτηση-μέλος capacity() επιστρέφει το πλήθος των στοιχείων που χωράνε στο vector τη στιγμή αυτή (το vector θα &quot;αναμορφωθεί&quot; αυτόματα για να χωρέσει πρόσθετα στοιχεία).</li>
</ul>
<p>Μπορούμε επίσης να αρχικοποιήσουμε το vector με έναν αριθμό στοιχείων:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vd1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.23</span><span class="p">);</span> <span class="c1">// 10 items, 0.23 each</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vd2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>      <span class="c1">// 10 items, of &quot;double()&quot; value (that is, 0)</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vd3</span> <span class="o">=</span> <span class="n">vd2</span><span class="p">;</span>    <span class="c1">// copy constructor</span>
</pre></div>
</div>
<p>Στη δεύτερη περίπτωση, καλείται ο default constructor για την αρχικοποίηση κάθε στοιχείου του vector, αν το στοιχείο είναι τύπου native (άρα δεν έχει constructor) τότε η αρχικοποίηση είναι στην τιμή 0. Στην τρίτη περίπτωση δημιουργείται ένα νέο vector αντιγράφοντας τα στοιχεία ενός προϋπάρχοντος.</p>
<p>Πολλές φορές ξέρουμε ότι θα χρειαστούμε έναν πίνακα Ν στοιχείων (π.χ. Ν=1000) αλλά δεν θέλουμε αρχικοποίηση. Τότε είναι πιο αποδοτικό να ορίσουμε ένα empty vector και να υποδείξουμε ότι θα πρέπει να χωρά Ν στοιχεία. Αυτό εμποδίζει τις χρονοβόρες αυτόματες αλλαγές μεγέθους του vector:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>      <span class="c1">// an empty vector</span>
<span class="n">vi</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</pre></div>
</div>
<p>Τα vectors είναι πολύ αποδοτικά στην τυχαία προσπέλαση του i-οστού στοιχείου και την προσθήκη νέου στοιχείου στο τέλος του vector (αν θέλετε αποδοτικές εισαγωγές-διαγραφές πρέπει να χρησιμοποιήσετε άλλον τύπο container!). Η εισαγωγή στο τέλος γίνεται ως εξής:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>

<span class="n">vi</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">vi</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span>
<span class="n">vi</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">23</span><span class="p">);</span>
</pre></div>
</div>
<p>Η προσπέλαση γίνεται με τον τελεστή [] για ανάγνωση και εγγραφή:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vi</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">vi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>ΠΡΟΣΟΧΗ!!!</strong> Ο τελεστής [] <strong>δεν ελέγχει</strong> αν προσπαθείτε να διαβάσετε ή να γράψετε πέρα από το τρέχον μέγιστο στοιχείο του vector! Αυτό φυσικά θα είναι μάλλον καταστροφικό για το προγραμμά σας.. Αν φοβάστε ότι κάτι τέτοιο μπορεί να συμβεί, χρησιμοποιήστε τη συνάρτηση-μέλος at(i), η οποία &quot;ρίχνει&quot; ένα exception αν το i είναι εκτός των ορίων του vector. Τόσο το [i] όσο και το at(i) επιστρέφουν μια αναφορά (reference) στο i-οστό στοιχείο του vector.</p>
</div>
<p>Με τη βοήθεια του [] μπορείτε να τυπώσετε τα περιεχόμενα του vector ως εξής (η μέθοδος αυτή δεν συνηθίζεται όμως! Για μια πιο &quot;επαγγελματική&quot; μέθοδο δείτε στα επόμενα):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// cycle trough vector via index</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">vd1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vd1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Η &quot;επαγγελματική&quot; μέθοδος χρησιμοποιεί iterators:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vd2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mf">0.23</span><span class="p">);</span> <span class="c1">// 10 items, 0.23 each</span>

<span class="c1">// cycle through vector via iterator</span>
<span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">vdp</span><span class="o">=</span><span class="n">vd2</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">vdp</span><span class="o">!=</span><span class="n">vd2</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">vdp</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">vdp</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Παρατηρήσεις:</p>
<ul>
<li><p class="first">Ο iterator πρέπει να έχει τον αντίστοιχο τύπο με το vector: εδώ είναι <tt class="docutils literal"><span class="pre">vector&lt;double&gt;::iterator</span></tt>.</p>
<ul class="simple">
<li>Μια const παραλλαγή (<tt class="docutils literal"><span class="pre">vector&lt;double&gt;::const_iterator</span></tt>) επιτρέπει την ανάγνωση αλλά όχι και την εγγραφή ενός στοιχείου.</li>
</ul>
</li>
<li><p class="first">Το στοιχείο που &quot;δείχνει&quot; ο iterator προσπελαύνεται μέσω του τελεστή *</p>
</li>
<li><p class="first">Η συνάρτηση-μέλος begin() επιστρέφει έναν iterator στο πρώτο στοιχείο του vector.</p>
</li>
<li><p class="first">Η συνάρτηση-μέλος end() επιστρέφει έναν iterator <strong>αμέσως μετά το τελευταίο</strong> στοιχείο του vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Ποτέ!!</strong> δεν προσπελαύνουμε το στοιχείο που δείχνει το end(), παρά μόνο έως το προηγούμενο από αυτό!</p>
</div>
</li>
<li><p class="first">Η αύξηση του iterator κατά 1 (++vdp) έχει ως συνέπεια ο iterator να δείχνει στο επόμενο στοιχείο του vector.</p>
</li>
</ul>
</div>
<div class="section" id="vectors">
<h2>Vectors: Αναζήτηση και Ταξινόμηση<a class="headerlink" href="#vectors" title="Permalink to this headline">¶</a></h2>
<p>Η αναζήτηση και ταξινόμηση vectors μπορεί να γίνει μέσω των αντίστοιχων STL Algorithms. Προσθέσετε στα includes σας:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;algorithm&gt;</span>
</pre></div>
</div>
<p>Η αναζήτηση γίνεται μέσω του αλγορίθμου <tt class="docutils literal"><span class="pre">find</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// init vector via a range</span>
<span class="kt">int</span> <span class="n">tmpi</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span> <span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi2</span><span class="p">(</span><span class="n">tmpi</span><span class="p">,</span><span class="n">tmpi</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span>       <span class="c1">// REMEMBER! it&#39;s [first,last)</span>

<span class="c1">// finding things into vectors (via STL algorithm find() - include &lt;algorithm&gt;!)</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">vip</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">vi2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">23</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">vip</span><span class="o">==</span><span class="n">vi2</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;not found!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;found!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>Ο τύπος δεδομένων που φυλάσσεται στο vector πρέπει αν υποστηρίζει τον τελεστή =</li>
<li>Στον αλγόριθμο δίνουμε την αρχή και το τέλος της έρευνας (iterators).</li>
<li>Αν το στοιχείο βρεθεί, επιστρέφεται ένας iterator σε αυτό.</li>
<li>Αν όχι, επιστρέφεται ο iterator του end().</li>
</ul>
<p>Η ταξινόμηση γίνεται ομοίως εύκολα μέσω του αλγορίθμου <tt class="docutils literal"><span class="pre">sort</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// sort a vector (via STL algorithm sort() - needs randomaccess iterators and vector has them)</span>
<span class="c1">// this modifies vector in-place!</span>
<span class="n">sort</span><span class="p">(</span><span class="n">vi2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// use &lt; to sort, ordering of identical items is undefined</span>
</pre></div>
</div>
<ul class="simple">
<li>Η ταξινόμηση γίνεται εξ'ορισμού με τον τελεστή &lt; (σε αύξουσα σειρά), ο τελεστής αυτός πρέπει να έχει οριστεί για τον τύπο δεδομένων που περιέχει το vector.</li>
<li>Ο αλγόριθμος sort απαιτεί <strong>random access iterators</strong> (iterators που μπορούν να δείξουν σε τυχαία θέση i του container - οι iterators του vector είναι τέτοιοι, δεν ισχύει όμως αυτό για κάποια άλλα containers!).</li>
</ul>
<p>Τι μπορεί να γίνει αν δεν θέλουμε αύξουσα ταξινόμηση; Δημιουργούμε τη δική μας συνάρτηση (ή ένα αντικείμενο-συνάρτηση - για αυτό όμως δεν θα μιλήσουμε εδώ!) σύγκρισης δύο στοιχείων και το τροφοδοτούμε στο sort, όπως στο επόμενο παράδειγμα φθίνουσας ταξινόμησης:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// function used for custom (descending) sorting</span>
<span class="kt">bool</span> <span class="n">mycmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">sort</span><span class="p">(</span><span class="n">vi2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">mycmp</span><span class="p">);</span>   <span class="c1">// use custom function that provides &gt; sorting</span>
</pre></div>
</div>
</div>
<div class="section" id="stl-vector-employees">
<h2>Παράδειγμα με STL Vector: Employees<a class="headerlink" href="#stl-vector-employees" title="Permalink to this headline">¶</a></h2>
<p>Σκοπεύουμε να ταξινομήσουμε εγγραφές τύπου Employee σε ένα vector, συνεπώς πρέπει να ορίσουμε τον τελεστή &lt; για την κλάση Employee. Αυτό γίνεται στη συνέχεια, ορίζοντας τον τελεστή ως μέλος της κλάσης Employee (σε αντίθεση με τα &lt;&lt; και &gt;&gt; που ήταν friends της κλάσης).</p>
<p>Δηλώνουμε τον τελεστή &lt; στον ορισμό της κλάσης Employee (στο employee.h):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">empl2</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Παρατηρήστε τη διπλή χρήση του <tt class="docutils literal"><span class="pre">const</span></tt> στη δήλωση της συνάρτησης: την πρώτη φορά δεσμευόμαστε ότι δεν θα τροποποιήσουμε το όρισμα empl2, ενώ τη δεύτερη φορά δεσμευόμαστε ότι η συνάρτηση δεν τροποποιεί το αντικείμενο για το οποίο καλείται η συνάρτηση (this).</p>
<p>Στη συνέχεια, ορίζουμε τη συνάρτηση του τελεστή στο employee.cpp:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Employee</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">empl2</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lastname</span><span class="o">&lt;</span><span class="n">empl2</span><span class="p">.</span><span class="n">lastname</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lastname</span><span class="o">&gt;</span><span class="n">empl2</span><span class="p">.</span><span class="n">lastname</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="c1">// lastnames are equal here</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">firstname</span><span class="o">&lt;</span><span class="n">empl2</span><span class="p">.</span><span class="n">firstname</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">firstname</span><span class="o">&gt;</span><span class="n">empl2</span><span class="p">.</span><span class="n">firstname</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="c1">// lastnames and firstnames are equal here</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">age</span><span class="o">&lt;</span><span class="n">empl2</span><span class="p">.</span><span class="n">age</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">age</span><span class="o">&gt;</span><span class="n">empl2</span><span class="p">.</span><span class="n">age</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="c1">// lastnames, firstnames and ages are equal here</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">salary</span><span class="o">&lt;</span><span class="n">empl2</span><span class="p">.</span><span class="n">salary</span><span class="p">)</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// empl2 salary is greater or equal</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Η σύγκριση συγκρίνει πρώτα το lastname, μετά το firstname, μετά το  age και τέλος το salary.</p>
<p>Στη συνάρτηση main() (employeemain.cpp) διαβάζουμε τις εγγραφές από το αρχείο records.txt όπως στην πορηγούμενη ενότητα και τοποθετούμε τις νέες εγγραφές σε ένα vector.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">ve</span><span class="p">;</span>    <span class="c1">// create a new empty vector for Employee objects</span>

<span class="c1">// create input file object and open it</span>
<span class="n">ifstream</span> <span class="n">ifs</span><span class="p">(</span><span class="s">&quot;records.txt&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifs</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">// file open error</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cannot open input file!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Employee</span> <span class="n">empl</span><span class="p">;</span>

<span class="c1">// read employee records until EOF or other error</span>
<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ifs</span><span class="o">&gt;&gt;</span><span class="n">empl</span><span class="p">)){</span>
      <span class="k">break</span><span class="p">;</span>    <span class="c1">// input stream error - exit while loop</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// store valid record into vector</span>
      <span class="n">ve</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">empl</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">catch</span><span class="p">(</span><span class="n">runtime_error</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// do nothing - skip invalid record</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// NOTE: no actual need to close file - destructor will do it if we don&#39;t</span>
<span class="n">ifs</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Όταν τοποθετούμε ένα αντικείμενο στο vector (και σε κάθε STL container), αυτό που πραγματικά αποθηκεύεται είναι ένα <strong>αντίγραφο</strong> του αντικειμένου!</p>
</div>
<p>Στη συνέχεια μπορούμε να ταξινομήσουμε τις εγγραφές με τον τελεστή &lt;</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// sort records - this needs the &lt; operator to be defined for Employee class</span>
<span class="n">sort</span><span class="p">(</span><span class="n">ve</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ve</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
<p>Εναλλακτικά μπορούμε να δημιουργήσουμε τις δκές μας συναρτήσεις ταξινόμησης, όπως εδώ (αύξουσα, κατά ηλικία):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">cmp_employees_by_age</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">e1</span><span class="p">,</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">e1</span><span class="p">.</span><span class="n">get_age</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">.</span><span class="n">get_age</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ή εδώ (φθίνουσα, κατά μισθό):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">cmp_employees_by_salary_descending</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">e1</span><span class="p">,</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">e1</span><span class="p">.</span><span class="n">get_salary</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">e2</span><span class="p">.</span><span class="n">get_salary</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>τις οποίες συναρτήσεις μπορούμε να τροφορδοτήσουμε στην sort():</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// sort records - this time by age of employees</span>
<span class="n">sort</span><span class="p">(</span><span class="n">ve</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ve</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">cmp_employees_by_age</span><span class="p">);</span>

<span class="c1">// sort records - this time by salary of employees and descending!</span>
<span class="n">sort</span><span class="p">(</span><span class="n">ve</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ve</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">cmp_employees_by_salary_descending</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">C++ Lectures v1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, mistral.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.2.
    </div>
  </body>
</html>