Scanning με το Plex
=====================
Η **λεκτική ανάλυση** (scanning) χρησιμοποιείται για να χωρίσουμε ένα κείμενο εισόδου (σε κάποια γλώσσα προγραμματισμού ή εφαρμογής) σε **σύμβολα** (tokens). Σε κανονικές συνθήκες, απαιτούμε **όλο** το κείμενο να μπορεί να αναγνωριστεί ως σύμβολα: αν υπάρχει μέρος του κειμένου που δεν ταιριάζει με κανένα σύμβολο, θέλουμε να παράγεται σφάλμα εκτέλεσης.

Αν και μπορούμε να αναλύσουμε το κείμενο εισόδου με πολλαπλές regular expressions, στα επόμενα θα χρησιμοποιήσουμε το module ``plex``. Αυτό **δεν ανήκει** στη στάνταρ βιβλιοθήκη της Python, έτσι πρέπει να το κατεβάσουμε (για την Python3 βρείτε ένα ανεπίσημο patch :download:`εδώ<Plex-2.0.1.tar.gz>`) και να το εγκαταστήσουμε στο σύστημά μας.

Οδηγίες εγκατάστασης
-----------------------
Εάν το module ``plex`` δεν υπάρχει στο σύστημά σας, θα πρέπει να το εγκαταστήσετε. Υπάρχουν πολλοί τρόποι, εδώ συνιστούμε τη χρήση του εργαλείου **virtualenv**. Αυτό μας δίνει τη δυνατότητα να δημιουργήσουμε ένα ξεχωριστό περιβάλλον εκτέλεσης Python, διαφορετικό από του συστήματος. Έτσι μπορούμε να εγκαταστήσουμε ό,τι Python module θέλουμε, χωρίς δικαιώματα administrator και χωρίς να αλλοιώνουμε την εγκατάσταση Python του συστήματος!

1. Έχετε το ``virtualenv``; Αν όχι, εγκαταστήστε το πριν προχωρήσετε (ή παρακαλέστε ευγενικά τον administrator σας να το κάνει). Σε πρόσφατο Ubuntu π.χ. δίνετε:

::

	sudo apt-get install python-virtualenv
		   
2. Μεταφερθείτε στον φάκελο που θα φτιάξετε το νέο περιβάλλον και δημιουργήστε το:

::

	cd <your virtual env folder> 
	virtualenv -p python3 venv

3. Στον φάκελο ``venv`` η προηγούμενη εντολή φτιάχνει ένα νέο περιβάλλον εκτέλεσης με την Python3. Για να το ενεργοποιήσετε:

::

	source venv/bin/activate

(το τελευταίο πρέπει να το κάνετε πάντα πριν εκτελέσετε ένα πρόγραμμα στο περιβάλλον αυτό! Για να βγείτε από το περιβάλλον, δώστε ``deactivate`` ή απλά κλείστε το shell)		 

	
4. Φτιάξτε ένα αρχείο ``requirements.txt``. Εδώ βάζετε τα modules που θέλετε να υπάρχουν στο περιβάλλον σας, ένα module ανά γραμμή. Modules θα βρείτε στο επίσημο `PyPI - the Python Package Index <https://pypi.python.org/pypi>`_ (γράψτε απλά το όνομα του module). Εναλλακτικά, γράψτε το πλήρες path στο αρχείο εγκατάστασης, αν το έχετε ήδη στον υπολογιστή σας. Έχοντας ήδη κατεβάσει το :download:`Python3 patch<Plex-2.0.1.tar.gz>` του Plex, το ``requirements.txt`` θα περιέχει:

::

	/full/path/to/locally/saved/Plex-2.0.1.tar.gz



5. Εγκαταστήστε τα πακέτα σας στο περιβάλλον εκτέλεσης (πάντα με το περιβάλλον **ενεργοποιημένο**!):

::

	pip install --upgrade -r requirements.txt




Απλό παράδειγμα χωρίς έλεγχο λαθών
--------------------------------------
Μην ξεχάσετε να φορτώσετε το module plex:

..	code-block:: python
   
	import plex

Ως πρώτο παράδειγμα, θέλουμε να κατασκευάσουμε έναν scanner που αναγνωρίζει τα σύμβολα ``123`` και ``abc`` (και **τίποτα αλλο**!). Αρχικά κατασκευάζουμε ένα ``plex.Lexicon``, μια λίστα από ζευγάρια ``((pattern,action)``. Το ``pattern`` είναι ένα πρότυπο αναγνώρισης (όπως οι regular expressions που έχουμε ήδη δει) και το ``action`` καθορίζει τι θα επιστρέψει ο scanner όταν ταιριάξει κείμενο με το αντίστοιχο pattern.

Στο παράδειγμα που ακολουθεί, θέλουμε με την εμφάνιση του abc να επιστρέφεται το string ``"ABC_TOKEN"``, ενώ με την εμφάνιση του 123 να επιστρέφεται το string ``"123_TOKEN"``. Επίσης, θέλουμε να αγνοούμε ένα η περισσότερα κενα, tab και newlines (ως action χρησιμοποιείται η ειδική σταθερά ``plex.IGNORE``). Το πώς κατασκευάζεται το pattern θα το δούμε αργότερα.

..	code-block:: python
   
	# the scanner lexicon - constructor argument is a list of (pattern,action ) tuples
	lexicon = plex.Lexicon([
		(plex.Str("abc"),"ABC_TOKEN"),
		(plex.Str("123"),"123_TOKEN"),
		(plex.Rep1(plex.Any(" \t\n")),plex.IGNORE)
		])

Στη συνέχεια, δημιουργούμε ένα αντικείμενο της κλάσης ``plex.Scanner`` για συγκεκριμένο λεξικό και αρχείο:

..	code-block:: python
   
	fp = open("plex1.txt","r")
	scanner = plex.Scanner(lexicon,fp)

Αμέσως μετά, μπορούμε να καλέσουμε επαναληπτικά τη μέθοδο ``read()`` του αντικειμένου scanner. Αυτή η μέθοδος επιστρέφει για κάθε token που αναγνωρίζει ένα ζευγάρι ``(value-returned-from-action,matched-text)``. Όταν δεν υπάρχουν άλλα σύμβολα στο αρχείο εισόδου (end-of-text, EOT), επιστρέφεται το ζευγάρι ``(None, '')``.

..	code-block:: python
   
	while True:
		token,matched = scanner.read()
	
		if not token: break	# reached EOT
	
		print(token,matched)
	 
Το συνολικό πρόγραμμα έχει ως εξής:

.. literalinclude:: plex1.py
   :language: python
   
Φυσικά, με το λεξικό που χρησιμοποιείται, το αρχείο εισόδου πρέπει να αποτελείται **μόνο** από 123 και abc, π.χ. το
:download:`plex1.txt<plex1.txt>`.

.. 	note::

	Μπορείτε να κατεβάσετε `όλα τα αρχεία python και txt <https://gist.github.com/mixstef/25166fe36f89aed4acee>`_. 


Προσθέτοντας έλεγχο λαθών (exception handling)
----------------------------------------------------
Όταν στο αρχείο εισόδου βρεθεί κείμενο που δεν ταιριάζει σε κανένα σύμβολο, δημιουργείται σφάλμα (exception) του τύπου ``plex.errors.PlexError``. Μπορούμε να αναγνωρίσουμε την κατάσταση αυτή με τη δομή ``try: ... except: ...`` της Python
και να βρούμε σε ποιο σημείο του κειμένου συνέβει το σφάλμα, μέσω της μεθόδου ``position()`` του scanner:

.. literalinclude:: plex2.py
   :language: python
   
Εφαρμόζεται στο :download:`plex2.txt<plex2.txt>`.

Plex patterns
-----------------
Αν S, S1, S2 είναι strings, και Β, Ε χαρακτήρες, μπορούν να κατασκευαστούν τα εξής patterns ταιριάσματος:

================	=====================================================
Str(S)			ταιριάζει το string S
Str(S1,S2,..)		ταιριάζει ένα από τα S1, S2, .. 
Any(S)   		ταιριάζει κάθε μονό χαρακτήρα του S
AnyBut(S) 		ταιριάζει κάθε χαρακτήρα που δεν ανήκει στο S
AnyChar   		ταιριάζει κάθε μονό χαρακτήρα (και το newline)
Empty        		ταιριάζει το κενό string
Bol,Eol,Eof   		ταιριάζει στην αρχή/τέλος γραμμής και τέλος κειμένου
Range(“BE..”) 		ταιριάζει περιοχές από το Β έως το Ε κ.ο.κ
================	=====================================================

Επίσης, αν P, P1, P2 είναι patterns που έχουν ήδη κατασκευαστεί, μπορούν να γίνουν οι εξής συνδυασμοί:

=====================	=====================================================
P1+P2 ή Seq(P1,P2)	το P1 ακολουθούμενο από το P2
P1|P2 ή Alt(P1,P2)	είτε το P1 είτε το P2 (εναλλαγή)
Opt(P) 			0 ή 1 φορά το P (προαιρετικό)
Rep(P)  	 	0 ή περισσότερες φορές το P
Rep1(P) 		1 ή περισσότερες φορές το P
NoCase(P)  Case(P)	το P, αγνοώντας (ή λαμβάνοντας υπ'όψη) κεφαλαία-μικρά
=====================	=====================================================

(για την πλήρη τεκμηρίωση του plex δείτε το https://pythonhosted.org/plex/) 

Κανόνες Ταιριάσματος
-----------------------
Στην περίπτωση που υπάρχουν εναλλακτικές επιλογές ταιριάσματος, το plex εφαρμόζει με τη σειρά τους εξής κανόνες:

1. Προτιμάται η επιλογή που επιτυγχάνει το μακρύτερο ταίριασμα (αυτή που ταιριάζει περισσότερους χαρακτήρες).
2. Εάν οι επιλογές ταιριάζουν τον ίδιο αριθμό χαρακτήρων, επιλέγεται η πρώτη, με τη σειρά δήλωσης στο λεξικό.

Ο κανόνας του μακρύτερου ταιριάσματος
----------------------------------------
Γιατί ταιριάζει το ``tomcat`` αντί του ``tom``:

.. literalinclude:: plex3.py
   :language: python
   
Εφαρμόζεται στο :download:`plex3.txt<plex3.txt>`.

Αγνοώντας κείμενο με βάση το μακρύτερο ταίριασμα
--------------------------------------------------------
Δουλεύει για εύρεση tokens με μήκος > 1.

.. literalinclude:: plex4.py
   :language: python
   
Εφαρμόζεται στο :download:`plex4.txt<plex4.txt>`.

Σε ταίριασμα ίδιου μήκους προηγείται ό,τι δηλώθηκε πρώτα
----------------------------------------------------------
Αν το identifier rule είναι πρώτο, δεν θα ταιριάξουμε ποτέ τα keywords!

 .. literalinclude:: plex5.py
   :language: python
   
Εφαρμόζεται στο :download:`plex5.txt<plex5.txt>`.

Αγνοώντας single-line σχόλια
--------------------------------------
Το ζητούμενο είναι η κατασκευή scanner που να αναγνωρίζει

* identifiers
* ακέραιες σταθερές
* σταθερές floating point (στις μορφές xx.yy και .yy, σε οποιοδήποτε αριθμό ψηφίων x και y)
* σταθερές hex (στη μορφή 0x...)
* τα keywords if, the, else, end
* τους τελεστές + - * / = < > (τελεστές ενός χαρακτήρα)

και να αγνοεί:

* newline, tab, space
* οτιδήποτε ακολουθεί // μέχρι το τέλος της γραμμής 


.. literalinclude:: plex6.py
   :language: python
   
Εφαρμόζεται στο :download:`plex6.txt<plex6.txt>`.

Αγνοώντας multiple-line σχόλια /* ... \*/
--------------------------------------------
Αν τα block σχόλια τερματίζονται με έναν μόνο χαρακτήρα, τότε μπορούμε να εφαρμόσουμε μια λύση όπως στο προηγούμενο. Στην περίπτωση που ο τερματισμός των σχολίων απαιτεί μια ακολουθία χαρακτήρων (όπως το ``*/``), είναι πιο εύκολο να χρησιμοποιήσουμε ξεχωριστό state όσο βρισκόμαστε μέσα στο σχόλιο. Εκτός από την απλότητα, το ξεχωριστό state επιτρέπει το χειρισμό nested σχολίων (π.χ. με έναν counter που παρακολουθεί το επίπεδο nesting -δεν υλοποιείται όμως στο επόμενο παράδειγμα) και δεν απαιτεί την αποθήκευση πολλών χαρακτήρων από τον scanner μέχρι το τέλος του σχολίου:


.. literalinclude:: plex7.py
   :language: python
   
Εφαρμόζεται στο :download:`plex7.txt<plex7.txt>`.


